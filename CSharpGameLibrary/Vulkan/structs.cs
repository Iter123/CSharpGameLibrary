//autogenerated on 8/21/2016 10:52:32 PM
using System;
using System.Runtime.InteropServices;

namespace CSGL.Vulkan {
    public struct VkInstance : IEquatable<VkInstance> {
        public IntPtr native;

        public static VkInstance Null { get; } = new VkInstance();

        public override bool Equals(object other) {
            if (other is VkInstance) {
                return Equals((VkInstance)other);
            }
            return false;
        }

        public bool Equals(VkInstance other) {
            return other.native == native;
        }

        public static bool operator == (VkInstance a, VkInstance b) {
            return a.Equals(b);
        }

        public static bool operator != (VkInstance a, VkInstance b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkPhysicalDevice : IEquatable<VkPhysicalDevice> {
        public IntPtr native;

        public static VkPhysicalDevice Null { get; } = new VkPhysicalDevice();

        public override bool Equals(object other) {
            if (other is VkPhysicalDevice) {
                return Equals((VkPhysicalDevice)other);
            }
            return false;
        }

        public bool Equals(VkPhysicalDevice other) {
            return other.native == native;
        }

        public static bool operator == (VkPhysicalDevice a, VkPhysicalDevice b) {
            return a.Equals(b);
        }

        public static bool operator != (VkPhysicalDevice a, VkPhysicalDevice b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDevice : IEquatable<VkDevice> {
        public IntPtr native;

        public static VkDevice Null { get; } = new VkDevice();

        public override bool Equals(object other) {
            if (other is VkDevice) {
                return Equals((VkDevice)other);
            }
            return false;
        }

        public bool Equals(VkDevice other) {
            return other.native == native;
        }

        public static bool operator == (VkDevice a, VkDevice b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDevice a, VkDevice b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkQueue : IEquatable<VkQueue> {
        public IntPtr native;

        public static VkQueue Null { get; } = new VkQueue();

        public override bool Equals(object other) {
            if (other is VkQueue) {
                return Equals((VkQueue)other);
            }
            return false;
        }

        public bool Equals(VkQueue other) {
            return other.native == native;
        }

        public static bool operator == (VkQueue a, VkQueue b) {
            return a.Equals(b);
        }

        public static bool operator != (VkQueue a, VkQueue b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkCommandBuffer : IEquatable<VkCommandBuffer> {
        public IntPtr native;

        public static VkCommandBuffer Null { get; } = new VkCommandBuffer();

        public override bool Equals(object other) {
            if (other is VkCommandBuffer) {
                return Equals((VkCommandBuffer)other);
            }
            return false;
        }

        public bool Equals(VkCommandBuffer other) {
            return other.native == native;
        }

        public static bool operator == (VkCommandBuffer a, VkCommandBuffer b) {
            return a.Equals(b);
        }

        public static bool operator != (VkCommandBuffer a, VkCommandBuffer b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDeviceMemory : IEquatable<VkDeviceMemory> {
        public ulong native;

        public static VkDeviceMemory Null { get; } = new VkDeviceMemory();

        public override bool Equals(object other) {
            if (other is VkDeviceMemory) {
                return Equals((VkDeviceMemory)other);
            }
            return false;
        }

        public bool Equals(VkDeviceMemory other) {
            return other.native == native;
        }

        public static bool operator == (VkDeviceMemory a, VkDeviceMemory b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDeviceMemory a, VkDeviceMemory b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkCommandPool : IEquatable<VkCommandPool> {
        public ulong native;

        public static VkCommandPool Null { get; } = new VkCommandPool();

        public override bool Equals(object other) {
            if (other is VkCommandPool) {
                return Equals((VkCommandPool)other);
            }
            return false;
        }

        public bool Equals(VkCommandPool other) {
            return other.native == native;
        }

        public static bool operator == (VkCommandPool a, VkCommandPool b) {
            return a.Equals(b);
        }

        public static bool operator != (VkCommandPool a, VkCommandPool b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkBuffer : IEquatable<VkBuffer> {
        public ulong native;

        public static VkBuffer Null { get; } = new VkBuffer();

        public override bool Equals(object other) {
            if (other is VkBuffer) {
                return Equals((VkBuffer)other);
            }
            return false;
        }

        public bool Equals(VkBuffer other) {
            return other.native == native;
        }

        public static bool operator == (VkBuffer a, VkBuffer b) {
            return a.Equals(b);
        }

        public static bool operator != (VkBuffer a, VkBuffer b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkBufferView : IEquatable<VkBufferView> {
        public ulong native;

        public static VkBufferView Null { get; } = new VkBufferView();

        public override bool Equals(object other) {
            if (other is VkBufferView) {
                return Equals((VkBufferView)other);
            }
            return false;
        }

        public bool Equals(VkBufferView other) {
            return other.native == native;
        }

        public static bool operator == (VkBufferView a, VkBufferView b) {
            return a.Equals(b);
        }

        public static bool operator != (VkBufferView a, VkBufferView b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkImage : IEquatable<VkImage> {
        public ulong native;

        public static VkImage Null { get; } = new VkImage();

        public override bool Equals(object other) {
            if (other is VkImage) {
                return Equals((VkImage)other);
            }
            return false;
        }

        public bool Equals(VkImage other) {
            return other.native == native;
        }

        public static bool operator == (VkImage a, VkImage b) {
            return a.Equals(b);
        }

        public static bool operator != (VkImage a, VkImage b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkImageView : IEquatable<VkImageView> {
        public ulong native;

        public static VkImageView Null { get; } = new VkImageView();

        public override bool Equals(object other) {
            if (other is VkImageView) {
                return Equals((VkImageView)other);
            }
            return false;
        }

        public bool Equals(VkImageView other) {
            return other.native == native;
        }

        public static bool operator == (VkImageView a, VkImageView b) {
            return a.Equals(b);
        }

        public static bool operator != (VkImageView a, VkImageView b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkShaderModule : IEquatable<VkShaderModule> {
        public ulong native;

        public static VkShaderModule Null { get; } = new VkShaderModule();

        public override bool Equals(object other) {
            if (other is VkShaderModule) {
                return Equals((VkShaderModule)other);
            }
            return false;
        }

        public bool Equals(VkShaderModule other) {
            return other.native == native;
        }

        public static bool operator == (VkShaderModule a, VkShaderModule b) {
            return a.Equals(b);
        }

        public static bool operator != (VkShaderModule a, VkShaderModule b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkPipeline : IEquatable<VkPipeline> {
        public ulong native;

        public static VkPipeline Null { get; } = new VkPipeline();

        public override bool Equals(object other) {
            if (other is VkPipeline) {
                return Equals((VkPipeline)other);
            }
            return false;
        }

        public bool Equals(VkPipeline other) {
            return other.native == native;
        }

        public static bool operator == (VkPipeline a, VkPipeline b) {
            return a.Equals(b);
        }

        public static bool operator != (VkPipeline a, VkPipeline b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkPipelineLayout : IEquatable<VkPipelineLayout> {
        public ulong native;

        public static VkPipelineLayout Null { get; } = new VkPipelineLayout();

        public override bool Equals(object other) {
            if (other is VkPipelineLayout) {
                return Equals((VkPipelineLayout)other);
            }
            return false;
        }

        public bool Equals(VkPipelineLayout other) {
            return other.native == native;
        }

        public static bool operator == (VkPipelineLayout a, VkPipelineLayout b) {
            return a.Equals(b);
        }

        public static bool operator != (VkPipelineLayout a, VkPipelineLayout b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkSampler : IEquatable<VkSampler> {
        public ulong native;

        public static VkSampler Null { get; } = new VkSampler();

        public override bool Equals(object other) {
            if (other is VkSampler) {
                return Equals((VkSampler)other);
            }
            return false;
        }

        public bool Equals(VkSampler other) {
            return other.native == native;
        }

        public static bool operator == (VkSampler a, VkSampler b) {
            return a.Equals(b);
        }

        public static bool operator != (VkSampler a, VkSampler b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDescriptorSet : IEquatable<VkDescriptorSet> {
        public ulong native;

        public static VkDescriptorSet Null { get; } = new VkDescriptorSet();

        public override bool Equals(object other) {
            if (other is VkDescriptorSet) {
                return Equals((VkDescriptorSet)other);
            }
            return false;
        }

        public bool Equals(VkDescriptorSet other) {
            return other.native == native;
        }

        public static bool operator == (VkDescriptorSet a, VkDescriptorSet b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDescriptorSet a, VkDescriptorSet b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDescriptorSetLayout : IEquatable<VkDescriptorSetLayout> {
        public ulong native;

        public static VkDescriptorSetLayout Null { get; } = new VkDescriptorSetLayout();

        public override bool Equals(object other) {
            if (other is VkDescriptorSetLayout) {
                return Equals((VkDescriptorSetLayout)other);
            }
            return false;
        }

        public bool Equals(VkDescriptorSetLayout other) {
            return other.native == native;
        }

        public static bool operator == (VkDescriptorSetLayout a, VkDescriptorSetLayout b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDescriptorSetLayout a, VkDescriptorSetLayout b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDescriptorPool : IEquatable<VkDescriptorPool> {
        public ulong native;

        public static VkDescriptorPool Null { get; } = new VkDescriptorPool();

        public override bool Equals(object other) {
            if (other is VkDescriptorPool) {
                return Equals((VkDescriptorPool)other);
            }
            return false;
        }

        public bool Equals(VkDescriptorPool other) {
            return other.native == native;
        }

        public static bool operator == (VkDescriptorPool a, VkDescriptorPool b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDescriptorPool a, VkDescriptorPool b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkFence : IEquatable<VkFence> {
        public ulong native;

        public static VkFence Null { get; } = new VkFence();

        public override bool Equals(object other) {
            if (other is VkFence) {
                return Equals((VkFence)other);
            }
            return false;
        }

        public bool Equals(VkFence other) {
            return other.native == native;
        }

        public static bool operator == (VkFence a, VkFence b) {
            return a.Equals(b);
        }

        public static bool operator != (VkFence a, VkFence b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkSemaphore : IEquatable<VkSemaphore> {
        public ulong native;

        public static VkSemaphore Null { get; } = new VkSemaphore();

        public override bool Equals(object other) {
            if (other is VkSemaphore) {
                return Equals((VkSemaphore)other);
            }
            return false;
        }

        public bool Equals(VkSemaphore other) {
            return other.native == native;
        }

        public static bool operator == (VkSemaphore a, VkSemaphore b) {
            return a.Equals(b);
        }

        public static bool operator != (VkSemaphore a, VkSemaphore b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkEvent : IEquatable<VkEvent> {
        public ulong native;

        public static VkEvent Null { get; } = new VkEvent();

        public override bool Equals(object other) {
            if (other is VkEvent) {
                return Equals((VkEvent)other);
            }
            return false;
        }

        public bool Equals(VkEvent other) {
            return other.native == native;
        }

        public static bool operator == (VkEvent a, VkEvent b) {
            return a.Equals(b);
        }

        public static bool operator != (VkEvent a, VkEvent b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkQueryPool : IEquatable<VkQueryPool> {
        public ulong native;

        public static VkQueryPool Null { get; } = new VkQueryPool();

        public override bool Equals(object other) {
            if (other is VkQueryPool) {
                return Equals((VkQueryPool)other);
            }
            return false;
        }

        public bool Equals(VkQueryPool other) {
            return other.native == native;
        }

        public static bool operator == (VkQueryPool a, VkQueryPool b) {
            return a.Equals(b);
        }

        public static bool operator != (VkQueryPool a, VkQueryPool b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkFramebuffer : IEquatable<VkFramebuffer> {
        public ulong native;

        public static VkFramebuffer Null { get; } = new VkFramebuffer();

        public override bool Equals(object other) {
            if (other is VkFramebuffer) {
                return Equals((VkFramebuffer)other);
            }
            return false;
        }

        public bool Equals(VkFramebuffer other) {
            return other.native == native;
        }

        public static bool operator == (VkFramebuffer a, VkFramebuffer b) {
            return a.Equals(b);
        }

        public static bool operator != (VkFramebuffer a, VkFramebuffer b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkRenderPass : IEquatable<VkRenderPass> {
        public ulong native;

        public static VkRenderPass Null { get; } = new VkRenderPass();

        public override bool Equals(object other) {
            if (other is VkRenderPass) {
                return Equals((VkRenderPass)other);
            }
            return false;
        }

        public bool Equals(VkRenderPass other) {
            return other.native == native;
        }

        public static bool operator == (VkRenderPass a, VkRenderPass b) {
            return a.Equals(b);
        }

        public static bool operator != (VkRenderPass a, VkRenderPass b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkPipelineCache : IEquatable<VkPipelineCache> {
        public ulong native;

        public static VkPipelineCache Null { get; } = new VkPipelineCache();

        public override bool Equals(object other) {
            if (other is VkPipelineCache) {
                return Equals((VkPipelineCache)other);
            }
            return false;
        }

        public bool Equals(VkPipelineCache other) {
            return other.native == native;
        }

        public static bool operator == (VkPipelineCache a, VkPipelineCache b) {
            return a.Equals(b);
        }

        public static bool operator != (VkPipelineCache a, VkPipelineCache b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDisplayKHR : IEquatable<VkDisplayKHR> {
        public ulong native;

        public static VkDisplayKHR Null { get; } = new VkDisplayKHR();

        public override bool Equals(object other) {
            if (other is VkDisplayKHR) {
                return Equals((VkDisplayKHR)other);
            }
            return false;
        }

        public bool Equals(VkDisplayKHR other) {
            return other.native == native;
        }

        public static bool operator == (VkDisplayKHR a, VkDisplayKHR b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDisplayKHR a, VkDisplayKHR b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDisplayModeKHR : IEquatable<VkDisplayModeKHR> {
        public ulong native;

        public static VkDisplayModeKHR Null { get; } = new VkDisplayModeKHR();

        public override bool Equals(object other) {
            if (other is VkDisplayModeKHR) {
                return Equals((VkDisplayModeKHR)other);
            }
            return false;
        }

        public bool Equals(VkDisplayModeKHR other) {
            return other.native == native;
        }

        public static bool operator == (VkDisplayModeKHR a, VkDisplayModeKHR b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDisplayModeKHR a, VkDisplayModeKHR b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkSurfaceKHR : IEquatable<VkSurfaceKHR> {
        public ulong native;

        public static VkSurfaceKHR Null { get; } = new VkSurfaceKHR();

        public override bool Equals(object other) {
            if (other is VkSurfaceKHR) {
                return Equals((VkSurfaceKHR)other);
            }
            return false;
        }

        public bool Equals(VkSurfaceKHR other) {
            return other.native == native;
        }

        public static bool operator == (VkSurfaceKHR a, VkSurfaceKHR b) {
            return a.Equals(b);
        }

        public static bool operator != (VkSurfaceKHR a, VkSurfaceKHR b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkSwapchainKHR : IEquatable<VkSwapchainKHR> {
        public ulong native;

        public static VkSwapchainKHR Null { get; } = new VkSwapchainKHR();

        public override bool Equals(object other) {
            if (other is VkSwapchainKHR) {
                return Equals((VkSwapchainKHR)other);
            }
            return false;
        }

        public bool Equals(VkSwapchainKHR other) {
            return other.native == native;
        }

        public static bool operator == (VkSwapchainKHR a, VkSwapchainKHR b) {
            return a.Equals(b);
        }

        public static bool operator != (VkSwapchainKHR a, VkSwapchainKHR b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDebugReportCallbackEXT : IEquatable<VkDebugReportCallbackEXT> {
        public ulong native;

        public static VkDebugReportCallbackEXT Null { get; } = new VkDebugReportCallbackEXT();

        public override bool Equals(object other) {
            if (other is VkDebugReportCallbackEXT) {
                return Equals((VkDebugReportCallbackEXT)other);
            }
            return false;
        }

        public bool Equals(VkDebugReportCallbackEXT other) {
            return other.native == native;
        }

        public static bool operator == (VkDebugReportCallbackEXT a, VkDebugReportCallbackEXT b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDebugReportCallbackEXT a, VkDebugReportCallbackEXT b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkOffset2D {
        public int x;
        public int y;
    }

    public struct VkOffset3D {
        public int x;
        public int y;
        public int z;
    }

    public struct VkExtent2D {
        public uint width;
        public uint height;
    }

    public struct VkExtent3D {
        public uint width;
        public uint height;
        public uint depth;
    }

    public struct VkViewport {
        public float x;
        public float y;
        public float width;
        public float height;
        public float minDepth;
        public float maxDepth;
    }

    public struct VkRect2D {
        public VkOffset2D offset;
        public VkExtent2D extent;
    }

    public struct VkRect3D {
        public VkOffset3D offset;
        public VkExtent3D extent;
    }

    public struct VkClearRect {
        public VkRect2D rect;
        public uint baseArrayLayer;
        public uint layerCount;
    }

    public struct VkComponentMapping {
        public VkComponentSwizzle r;
        public VkComponentSwizzle g;
        public VkComponentSwizzle b;
        public VkComponentSwizzle a;
    }

    public struct VkPhysicalDeviceProperties {
        public uint apiVersion;
        public uint driverVersion;
        public uint vendorID;
        public uint deviceID;
        public VkPhysicalDeviceType deviceType;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
        public byte[] deviceName;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] pipelineCacheUUID;
        public VkPhysicalDeviceLimits limits;
        public VkPhysicalDeviceSparseProperties sparseProperties;
    }

    public struct VkExtensionProperties {
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
        public byte[] extensionName;
        public VkVersion specVersion;
    }

    public struct VkLayerProperties {
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
        public byte[] layerName;
        public VkVersion specVersion;
        public uint implementationVersion;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
        public byte[] description;
    }

    public struct VkApplicationInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public string pApplicationName;
        public VkVersion applicationVersion;
        public string pEngineName;
        public VkVersion engineVersion;
        public VkVersion apiVersion;
    }

    public struct VkAllocationCallbacks {
        public IntPtr pUserData;
        public IntPtr pfnAllocation;
        public IntPtr pfnReallocation;
        public IntPtr pfnFree;
        public IntPtr pfnInternalAllocation;
        public IntPtr pfnInternalFree;
    }

    public struct VkDeviceQueueCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkDeviceQueueCreateFlags flags;
        public uint queueFamilyIndex;
        public uint queueCount;
        public IntPtr pQueuePriorities;
    }

    public struct VkDeviceCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkDeviceCreateFlags flags;
        public uint queueCreateInfoCount;
        public IntPtr pQueueCreateInfos;
        public uint enabledLayerCount;
        public IntPtr ppEnabledLayerNames;
        public uint enabledExtensionCount;
        public IntPtr ppEnabledExtensionNames;
        public IntPtr pEnabledFeatures;
    }

    public struct VkInstanceCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkInstanceCreateFlags flags;
        public IntPtr pApplicationInfo;
        public uint enabledLayerCount;
        public IntPtr ppEnabledLayerNames;
        public uint enabledExtensionCount;
        public IntPtr ppEnabledExtensionNames;
    }

    public struct VkQueueFamilyProperties {
        public VkQueueFlags queueFlags;
        public uint queueCount;
        public uint timestampValidBits;
        public VkExtent3D minImageTransferGranularity;
    }

    public struct VkPhysicalDeviceMemoryProperties {
        public uint memoryTypeCount;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
        public VkMemoryType memoryTypes;
        public uint memoryHeapCount;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public VkMemoryHeap memoryHeaps;
    }

    public struct VkMemoryAllocateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public ulong allocationSize;
        public uint memoryTypeIndex;
    }

    public struct VkMemoryRequirements {
        public ulong size;
        public ulong alignment;
        public uint memoryTypeBits;
    }

    public struct VkSparseImageFormatProperties {
        public VkImageAspectFlags aspectMask;
        public VkExtent3D imageGranularity;
        public VkSparseImageFormatFlags flags;
    }

    public struct VkSparseImageMemoryRequirements {
        public VkSparseImageFormatProperties formatProperties;
        public uint imageMipTailFirstLod;
        public ulong imageMipTailSize;
        public ulong imageMipTailOffset;
        public ulong imageMipTailStride;
    }

    public struct VkMemoryType {
        public VkMemoryPropertyFlags propertyFlags;
        public uint heapIndex;
    }

    public struct VkMemoryHeap {
        public ulong size;
        public VkMemoryHeapFlags flags;
    }

    public struct VkMappedMemoryRange {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkDeviceMemory memory;
        public ulong offset;
        public ulong size;
    }

    public struct VkFormatProperties {
        public VkFormatFeatureFlags linearTilingFeatures;
        public VkFormatFeatureFlags optimalTilingFeatures;
        public VkFormatFeatureFlags bufferFeatures;
    }

    public struct VkImageFormatProperties {
        public VkExtent3D maxExtent;
        public uint maxMipLevels;
        public uint maxArrayLayers;
        public VkSampleCountFlags sampleCounts;
        public ulong maxResourceSize;
    }

    public struct VkDescriptorBufferInfo {
        public VkBuffer buffer;
        public ulong offset;
        public ulong range;
    }

    public struct VkDescriptorImageInfo {
        public VkSampler sampler;
        public VkImageView imageView;
        public VkImageLayout imageLayout;
    }

    public struct VkWriteDescriptorSet {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkDescriptorSet dstSet;
        public uint dstBinding;
        public uint dstArrayElement;
        public uint descriptorCount;
        public VkDescriptorType descriptorType;
        public IntPtr pImageInfo;
        public IntPtr pBufferInfo;
        public IntPtr pTexelBufferView;
    }

    public struct VkCopyDescriptorSet {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkDescriptorSet srcSet;
        public uint srcBinding;
        public uint srcArrayElement;
        public VkDescriptorSet dstSet;
        public uint dstBinding;
        public uint dstArrayElement;
        public uint descriptorCount;
    }

    public struct VkBufferCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkBufferCreateFlags flags;
        public ulong size;
        public VkBufferUsageFlags usage;
        public VkSharingMode sharingMode;
        public uint queueFamilyIndexCount;
        public uint[] pQueueFamilyIndices;
    }

    public struct VkBufferViewCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkBufferViewCreateFlags flags;
        public VkBuffer buffer;
        public VkFormat format;
        public ulong offset;
        public ulong range;
    }

    public struct VkImageSubresource {
        public VkImageAspectFlags aspectMask;
        public uint mipLevel;
        public uint arrayLayer;
    }

    public struct VkImageSubresourceLayers {
        public VkImageAspectFlags aspectMask;
        public uint mipLevel;
        public uint baseArrayLayer;
        public uint layerCount;
    }

    public struct VkImageSubresourceRange {
        public VkImageAspectFlags aspectMask;
        public uint baseMipLevel;
        public uint levelCount;
        public uint baseArrayLayer;
        public uint layerCount;
    }

    public struct VkMemoryBarrier {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkAccessFlags srcAccessMask;
        public VkAccessFlags dstAccessMask;
    }

    public struct VkBufferMemoryBarrier {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkAccessFlags srcAccessMask;
        public VkAccessFlags dstAccessMask;
        public uint srcQueueFamilyIndex;
        public uint dstQueueFamilyIndex;
        public VkBuffer buffer;
        public ulong offset;
        public ulong size;
    }

    public struct VkImageMemoryBarrier {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkAccessFlags srcAccessMask;
        public VkAccessFlags dstAccessMask;
        public VkImageLayout oldLayout;
        public VkImageLayout newLayout;
        public uint srcQueueFamilyIndex;
        public uint dstQueueFamilyIndex;
        public VkImage image;
        public VkImageSubresourceRange subresourceRange;
    }

    public struct VkImageCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkImageCreateFlags flags;
        public VkImageType imageType;
        public VkFormat format;
        public VkExtent3D extent;
        public uint mipLevels;
        public uint arrayLayers;
        public VkSampleCountFlags samples;
        public VkImageTiling tiling;
        public VkImageUsageFlags usage;
        public VkSharingMode sharingMode;
        public uint queueFamilyIndexCount;
        public uint[] pQueueFamilyIndices;
        public VkImageLayout initialLayout;
    }

    public struct VkSubresourceLayout {
        public ulong offset;
        public ulong size;
        public ulong rowPitch;
        public ulong arrayPitch;
        public ulong depthPitch;
    }

    public struct VkImageViewCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkImageViewCreateFlags flags;
        public VkImage image;
        public VkImageViewType viewType;
        public VkFormat format;
        public VkComponentMapping components;
        public VkImageSubresourceRange subresourceRange;
    }

    public struct VkBufferCopy {
        public ulong srcOffset;
        public ulong dstOffset;
        public ulong size;
    }

    public struct VkSparseMemoryBind {
        public ulong resourceOffset;
        public ulong size;
        public VkDeviceMemory memory;
        public ulong memoryOffset;
        public VkSparseMemoryBindFlags flags;
    }

    public struct VkSparseImageMemoryBind {
        public VkImageSubresource subresource;
        public VkOffset3D offset;
        public VkExtent3D extent;
        public VkDeviceMemory memory;
        public ulong memoryOffset;
        public VkSparseMemoryBindFlags flags;
    }

    public struct VkSparseBufferMemoryBindInfo {
        public VkBuffer buffer;
        public uint bindCount;
        public IntPtr pBinds;
    }

    public struct VkSparseImageOpaqueMemoryBindInfo {
        public VkImage image;
        public uint bindCount;
        public IntPtr pBinds;
    }

    public struct VkSparseImageMemoryBindInfo {
        public VkImage image;
        public uint bindCount;
        public IntPtr pBinds;
    }

    public struct VkBindSparseInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public uint waitSemaphoreCount;
        [MarshalAs(UnmanagedType.LPArray)]
        public VkSemaphore[] pWaitSemaphores;
        public uint bufferBindCount;
        public VkSparseBufferMemoryBindInfo[] pBufferBinds;
        public uint imageOpaqueBindCount;
        public VkSparseImageOpaqueMemoryBindInfo[] pImageOpaqueBinds;
        public uint imageBindCount;
        public VkSparseImageMemoryBindInfo[] pImageBinds;
        public uint signalSemaphoreCount;
        public VkSemaphore pSignalSemaphores;
    }

    public struct VkImageCopy {
        public VkImageSubresourceLayers srcSubresource;
        public VkOffset3D srcOffset;
        public VkImageSubresourceLayers dstSubresource;
        public VkOffset3D dstOffset;
        public VkExtent3D extent;
    }

    public struct VkImageBlit {
        public VkImageSubresourceLayers srcSubresource;
        public VkOffset3D srcOffsets;
        public VkImageSubresourceLayers dstSubresource;
        public VkOffset3D dstOffsets;
    }

    public struct VkBufferImageCopy {
        public ulong bufferOffset;
        public uint bufferRowLength;
        public uint bufferImageHeight;
        public VkImageSubresourceLayers imageSubresource;
        public VkOffset3D imageOffset;
        public VkExtent3D imageExtent;
    }

    public struct VkImageResolve {
        public VkImageSubresourceLayers srcSubresource;
        public VkOffset3D srcOffset;
        public VkImageSubresourceLayers dstSubresource;
        public VkOffset3D dstOffset;
        public VkExtent3D extent;
    }

    public struct VkShaderModuleCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkShaderModuleCreateFlags flags;
        public ulong codeSize;
        public IntPtr pCode;
    }

    public struct VkDescriptorSetLayoutBinding {
        public uint binding;
        public VkDescriptorType descriptorType;
        public uint descriptorCount;
        public VkShaderStageFlags stageFlags;
        public VkSampler[] pImmutableSamplers;
    }

    public struct VkDescriptorSetLayoutCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkDescriptorSetLayoutCreateFlags flags;
        public uint bindingCount;
        public VkDescriptorSetLayoutBinding[] pBindings;
    }

    public struct VkDescriptorPoolSize {
        public VkDescriptorType type;
        public uint descriptorCount;
    }

    public struct VkDescriptorPoolCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkDescriptorPoolCreateFlags flags;
        public uint maxSets;
        public uint poolSizeCount;
        public VkDescriptorPoolSize[] pPoolSizes;
    }

    public struct VkDescriptorSetAllocateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkDescriptorPool descriptorPool;
        public uint descriptorSetCount;
        public VkDescriptorSetLayout[] pSetLayouts;
    }

    public struct VkSpecializationMapEntry {
        public uint constantID;
        public uint offset;
        public ulong size;
    }

    public struct VkSpecializationInfo {
        public uint mapEntryCount;
        public IntPtr pMapEntries;
        public ulong dataSize;
        public IntPtr pData;
    }

    public struct VkPipelineShaderStageCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkPipelineShaderStageCreateFlags flags;
        public VkShaderStageFlags stage;
        public VkShaderModule module;
        public byte[] pName;
        public IntPtr pSpecializationInfo;
    }

    public struct VkComputePipelineCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkPipelineCreateFlags flags;
        public VkPipelineShaderStageCreateInfo stage;
        public VkPipelineLayout layout;
        public VkPipeline basePipelineHandle;
        public int basePipelineIndex;
    }

    public struct VkVertexInputBindingDescription {
        public uint binding;
        public uint stride;
        public VkVertexInputRate inputRate;
    }

    public struct VkVertexInputAttributeDescription {
        public uint location;
        public uint binding;
        public VkFormat format;
        public uint offset;
    }

    public struct VkPipelineVertexInputStateCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkPipelineVertexInputStateCreateFlags flags;
        public uint vertexBindingDescriptionCount;
        public VkVertexInputBindingDescription[] pVertexBindingDescriptions;
        public uint vertexAttributeDescriptionCount;
        public VkVertexInputAttributeDescription[] pVertexAttributeDescriptions;
    }

    public struct VkPipelineInputAssemblyStateCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkPipelineInputAssemblyStateCreateFlags flags;
        public VkPrimitiveTopology topology;
        public bool primitiveRestartEnable;
    }

    public struct VkPipelineTessellationStateCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkPipelineTessellationStateCreateFlags flags;
        public uint patchControlPoints;
    }

    public struct VkPipelineViewportStateCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkPipelineViewportStateCreateFlags flags;
        public uint viewportCount;
        public VkViewport[] pViewports;
        public uint scissorCount;
        public VkRect2D[] pScissors;
    }

    public struct VkPipelineRasterizationStateCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkPipelineRasterizationStateCreateFlags flags;
        public bool depthClampEnable;
        public bool rasterizerDiscardEnable;
        public VkPolygonMode polygonMode;
        public VkCullModeFlags cullMode;
        public VkFrontFace frontFace;
        public bool depthBiasEnable;
        public float depthBiasConstantFactor;
        public float depthBiasClamp;
        public float depthBiasSlopeFactor;
        public float lineWidth;
    }

    public struct VkPipelineMultisampleStateCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkPipelineMultisampleStateCreateFlags flags;
        public VkSampleCountFlags rasterizationSamples;
        public bool sampleShadingEnable;
        public float minSampleShading;
        public uint[] pSampleMask;
        public bool alphaToCoverageEnable;
        public bool alphaToOneEnable;
    }

    public struct VkPipelineColorBlendAttachmentState {
        public bool blendEnable;
        public VkBlendFactor srcColorBlendFactor;
        public VkBlendFactor dstColorBlendFactor;
        public VkBlendOp colorBlendOp;
        public VkBlendFactor srcAlphaBlendFactor;
        public VkBlendFactor dstAlphaBlendFactor;
        public VkBlendOp alphaBlendOp;
        public VkColorComponentFlags colorWriteMask;
    }

    public struct VkPipelineColorBlendStateCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkPipelineColorBlendStateCreateFlags flags;
        public bool logicOpEnable;
        public VkLogicOp logicOp;
        public uint attachmentCount;
        public VkPipelineColorBlendAttachmentState[] pAttachments;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
        public float[] blendConstants;
    }

    public struct VkPipelineDynamicStateCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkPipelineDynamicStateCreateFlags flags;
        public uint dynamicStateCount;
        public VkDynamicState[] pDynamicStates;
    }

    public struct VkStencilOpState {
        public VkStencilOp failOp;
        public VkStencilOp passOp;
        public VkStencilOp depthFailOp;
        public VkCompareOp compareOp;
        public uint compareMask;
        public uint writeMask;
        public uint reference;
    }

    public struct VkPipelineDepthStencilStateCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkPipelineDepthStencilStateCreateFlags flags;
        public bool depthTestEnable;
        public bool depthWriteEnable;
        public VkCompareOp depthCompareOp;
        public bool depthBoundsTestEnable;
        public bool stencilTestEnable;
        public VkStencilOpState front;
        public VkStencilOpState back;
        public float minDepthBounds;
        public float maxDepthBounds;
    }

    public struct VkGraphicsPipelineCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkPipelineCreateFlags flags;
        public uint stageCount;
        public VkPipelineShaderStageCreateInfo[] pStages;
        public IntPtr pVertexInputState;
        public IntPtr pInputAssemblyState;
        public IntPtr pTessellationState;
        public IntPtr pViewportState;
        public IntPtr pRasterizationState;
        public IntPtr pMultisampleState;
        public IntPtr pDepthStencilState;
        public IntPtr pColorBlendState;
        public IntPtr pDynamicState;
        public VkPipelineLayout layout;
        public VkRenderPass renderPass;
        public uint subpass;
        public VkPipeline basePipelineHandle;
        public int basePipelineIndex;
    }

    public struct VkPipelineCacheCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkPipelineCacheCreateFlags flags;
        public ulong initialDataSize;
        public byte[] pInitialData;
    }

    public struct VkPushConstantRange {
        public VkShaderStageFlags stageFlags;
        public uint offset;
        public uint size;
    }

    public struct VkPipelineLayoutCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkPipelineLayoutCreateFlags flags;
        public uint setLayoutCount;
        public VkDescriptorSetLayout[] pSetLayouts;
        public uint pushConstantRangeCount;
        public VkPushConstantRange[] pPushConstantRanges;
    }

    public struct VkSamplerCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkSamplerCreateFlags flags;
        public VkFilter magFilter;
        public VkFilter minFilter;
        public VkSamplerMipmapMode mipmapMode;
        public VkSamplerAddressMode addressModeU;
        public VkSamplerAddressMode addressModeV;
        public VkSamplerAddressMode addressModeW;
        public float mipLodBias;
        public bool anisotropyEnable;
        public float maxAnisotropy;
        public bool compareEnable;
        public VkCompareOp compareOp;
        public float minLod;
        public float maxLod;
        public VkBorderColor borderColor;
        public bool unnormalizedCoordinates;
    }

    public struct VkCommandPoolCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkCommandPoolCreateFlags flags;
        public uint queueFamilyIndex;
    }

    public struct VkCommandBufferAllocateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkCommandPool commandPool;
        public VkCommandBufferLevel level;
        public uint commandBufferCount;
    }

    public struct VkCommandBufferInheritanceInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkRenderPass renderPass;
        public uint subpass;
        public VkFramebuffer framebuffer;
        public bool occlusionQueryEnable;
        public VkQueryControlFlags queryFlags;
        public VkQueryPipelineStatisticFlags pipelineStatistics;
    }

    public struct VkCommandBufferBeginInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkCommandBufferUsageFlags flags;
        public IntPtr pInheritanceInfo;
    }

    public struct VkRenderPassBeginInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkRenderPass renderPass;
        public VkFramebuffer framebuffer;
        public VkRect2D renderArea;
        public uint clearValueCount;
        public VkClearValue[] pClearValues;
    }

    [StructLayout(LayoutKind.Explicit)]//union
    public struct VkClearColorValue {
        [FieldOffset(0)]
        public float float32;
        [FieldOffset(0)]
        public int int32;
        [FieldOffset(0)]
        public uint uint32;
    }

    public struct VkClearDepthStencilValue {
        public float depth;
        public uint stencil;
    }

    [StructLayout(LayoutKind.Explicit)]//union
    public struct VkClearValue {
        [FieldOffset(0)]
        public VkClearColorValue color;
        [FieldOffset(0)]
        public VkClearDepthStencilValue depthStencil;
    }

    public struct VkClearAttachment {
        public VkImageAspectFlags aspectMask;
        public uint colorAttachment;
        public VkClearValue clearValue;
    }

    public struct VkAttachmentDescription {
        public VkAttachmentDescriptionFlags flags;
        public VkFormat format;
        public VkSampleCountFlags samples;
        public VkAttachmentLoadOp loadOp;
        public VkAttachmentStoreOp storeOp;
        public VkAttachmentLoadOp stencilLoadOp;
        public VkAttachmentStoreOp stencilStoreOp;
        public VkImageLayout initialLayout;
        public VkImageLayout finalLayout;
    }

    public struct VkAttachmentReference {
        public uint attachment;
        public VkImageLayout layout;
    }

    public struct VkSubpassDescription {
        public VkSubpassDescriptionFlags flags;
        public VkPipelineBindPoint pipelineBindPoint;
        public uint inputAttachmentCount;
        public VkAttachmentReference[] pInputAttachments;
        public uint colorAttachmentCount;
        public VkAttachmentReference[] pColorAttachments;
        public VkAttachmentReference[] pResolveAttachments;
        public IntPtr pDepthStencilAttachment;
        public uint preserveAttachmentCount;
        public uint[] pPreserveAttachments;
    }

    public struct VkSubpassDependency {
        public uint srcSubpass;
        public uint dstSubpass;
        public VkPipelineStageFlags srcStageMask;
        public VkPipelineStageFlags dstStageMask;
        public VkAccessFlags srcAccessMask;
        public VkAccessFlags dstAccessMask;
        public VkDependencyFlags dependencyFlags;
    }

    public struct VkRenderPassCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkRenderPassCreateFlags flags;
        public uint attachmentCount;
        public VkAttachmentDescription[] pAttachments;
        public uint subpassCount;
        public VkSubpassDescription[] pSubpasses;
        public uint dependencyCount;
        public VkSubpassDependency[] pDependencies;
    }

    public struct VkEventCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkEventCreateFlags flags;
    }

    public struct VkFenceCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkFenceCreateFlags flags;
    }

    public struct VkPhysicalDeviceFeatures {
        public bool robustBufferAccess;
        public bool fullDrawIndexUint32;
        public bool imageCubeArray;
        public bool independentBlend;
        public bool geometryShader;
        public bool tessellationShader;
        public bool sampleRateShading;
        public bool dualSrcBlend;
        public bool logicOp;
        public bool multiDrawIndirect;
        public bool drawIndirectFirstInstance;
        public bool depthClamp;
        public bool depthBiasClamp;
        public bool fillModeNonSolid;
        public bool depthBounds;
        public bool wideLines;
        public bool largePoints;
        public bool alphaToOne;
        public bool multiViewport;
        public bool samplerAnisotropy;
        public bool textureCompressionETC2;
        public bool textureCompressionASTC_LDR;
        public bool textureCompressionBC;
        public bool occlusionQueryPrecise;
        public bool pipelineStatisticsQuery;
        public bool vertexPipelineStoresAndAtomics;
        public bool fragmentStoresAndAtomics;
        public bool shaderTessellationAndGeometryPointSize;
        public bool shaderImageGatherExtended;
        public bool shaderStorageImageExtendedFormats;
        public bool shaderStorageImageMultisample;
        public bool shaderStorageImageReadWithoutFormat;
        public bool shaderStorageImageWriteWithoutFormat;
        public bool shaderUniformBufferArrayDynamicIndexing;
        public bool shaderSampledImageArrayDynamicIndexing;
        public bool shaderStorageBufferArrayDynamicIndexing;
        public bool shaderStorageImageArrayDynamicIndexing;
        public bool shaderClipDistance;
        public bool shaderCullDistance;
        public bool shaderFloat64;
        public bool shaderInt64;
        public bool shaderInt16;
        public bool shaderResourceResidency;
        public bool shaderResourceMinLod;
        public bool sparseBinding;
        public bool sparseResidencyBuffer;
        public bool sparseResidencyImage2D;
        public bool sparseResidencyImage3D;
        public bool sparseResidency2Samples;
        public bool sparseResidency4Samples;
        public bool sparseResidency8Samples;
        public bool sparseResidency16Samples;
        public bool sparseResidencyAliased;
        public bool variableMultisampleRate;
        public bool inheritedQueries;
    }

    public struct VkPhysicalDeviceSparseProperties {
        public bool residencyStandard2DBlockShape;
        public bool residencyStandard2DMultisampleBlockShape;
        public bool residencyStandard3DBlockShape;
        public bool residencyAlignedMipSize;
        public bool residencyNonResidentStrict;
    }

    public struct VkPhysicalDeviceLimits {
        public uint maxImageDimension1D;
        public uint maxImageDimension2D;
        public uint maxImageDimension3D;
        public uint maxImageDimensionCube;
        public uint maxImageArrayLayers;
        public uint maxTexelBufferElements;
        public uint maxUniformBufferRange;
        public uint maxStorageBufferRange;
        public uint maxPushConstantsSize;
        public uint maxMemoryAllocationCount;
        public uint maxSamplerAllocationCount;
        public ulong bufferImageGranularity;
        public ulong sparseAddressSpaceSize;
        public uint maxBoundDescriptorSets;
        public uint maxPerStageDescriptorSamplers;
        public uint maxPerStageDescriptorUniformBuffers;
        public uint maxPerStageDescriptorStorageBuffers;
        public uint maxPerStageDescriptorSampledImages;
        public uint maxPerStageDescriptorStorageImages;
        public uint maxPerStageDescriptorInputAttachments;
        public uint maxPerStageResources;
        public uint maxDescriptorSetSamplers;
        public uint maxDescriptorSetUniformBuffers;
        public uint maxDescriptorSetUniformBuffersDynamic;
        public uint maxDescriptorSetStorageBuffers;
        public uint maxDescriptorSetStorageBuffersDynamic;
        public uint maxDescriptorSetSampledImages;
        public uint maxDescriptorSetStorageImages;
        public uint maxDescriptorSetInputAttachments;
        public uint maxVertexInputAttributes;
        public uint maxVertexInputBindings;
        public uint maxVertexInputAttributeOffset;
        public uint maxVertexInputBindingStride;
        public uint maxVertexOutputComponents;
        public uint maxTessellationGenerationLevel;
        public uint maxTessellationPatchSize;
        public uint maxTessellationControlPerVertexInputComponents;
        public uint maxTessellationControlPerVertexOutputComponents;
        public uint maxTessellationControlPerPatchOutputComponents;
        public uint maxTessellationControlTotalOutputComponents;
        public uint maxTessellationEvaluationInputComponents;
        public uint maxTessellationEvaluationOutputComponents;
        public uint maxGeometryShaderInvocations;
        public uint maxGeometryInputComponents;
        public uint maxGeometryOutputComponents;
        public uint maxGeometryOutputVertices;
        public uint maxGeometryTotalOutputComponents;
        public uint maxFragmentInputComponents;
        public uint maxFragmentOutputAttachments;
        public uint maxFragmentDualSrcAttachments;
        public uint maxFragmentCombinedOutputResources;
        public uint maxComputeSharedMemorySize;
        public uint maxComputeWorkGroupCount;
        public uint maxComputeWorkGroupInvocations;
        public uint maxComputeWorkGroupSize;
        public uint subPixelPrecisionBits;
        public uint subTexelPrecisionBits;
        public uint mipmapPrecisionBits;
        public uint maxDrawIndexedIndexValue;
        public uint maxDrawIndirectCount;
        public float maxSamplerLodBias;
        public float maxSamplerAnisotropy;
        public uint maxViewports;
        public uint maxViewportDimensions;
        public float viewportBoundsRange;
        public uint viewportSubPixelBits;
        public ulong minMemoryMapAlignment;
        public ulong minTexelBufferOffsetAlignment;
        public ulong minUniformBufferOffsetAlignment;
        public ulong minStorageBufferOffsetAlignment;
        public int minTexelOffset;
        public uint maxTexelOffset;
        public int minTexelGatherOffset;
        public uint maxTexelGatherOffset;
        public float minInterpolationOffset;
        public float maxInterpolationOffset;
        public uint subPixelInterpolationOffsetBits;
        public uint maxFramebufferWidth;
        public uint maxFramebufferHeight;
        public uint maxFramebufferLayers;
        public VkSampleCountFlags framebufferColorSampleCounts;
        public VkSampleCountFlags framebufferDepthSampleCounts;
        public VkSampleCountFlags framebufferStencilSampleCounts;
        public VkSampleCountFlags framebufferNoAttachmentsSampleCounts;
        public uint maxColorAttachments;
        public VkSampleCountFlags sampledImageColorSampleCounts;
        public VkSampleCountFlags sampledImageIntegerSampleCounts;
        public VkSampleCountFlags sampledImageDepthSampleCounts;
        public VkSampleCountFlags sampledImageStencilSampleCounts;
        public VkSampleCountFlags storageImageSampleCounts;
        public uint maxSampleMaskWords;
        public bool timestampComputeAndGraphics;
        public float timestampPeriod;
        public uint maxClipDistances;
        public uint maxCullDistances;
        public uint maxCombinedClipAndCullDistances;
        public uint discreteQueuePriorities;
        public float pointSizeRange;
        public float lineWidthRange;
        public float pointSizeGranularity;
        public float lineWidthGranularity;
        public bool strictLines;
        public bool standardSampleLocations;
        public ulong optimalBufferCopyOffsetAlignment;
        public ulong optimalBufferCopyRowPitchAlignment;
        public ulong nonCoherentAtomSize;
    }

    public struct VkSemaphoreCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkSemaphoreCreateFlags flags;
    }

    public struct VkQueryPoolCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkQueryPoolCreateFlags flags;
        public VkQueryType queryType;
        public uint queryCount;
        public VkQueryPipelineStatisticFlags pipelineStatistics;
    }

    public struct VkFramebufferCreateInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkFramebufferCreateFlags flags;
        public VkRenderPass renderPass;
        public uint attachmentCount;
        public VkImageView pAttachments;
        public uint width;
        public uint height;
        public uint layers;
    }

    public struct VkDrawIndirectCommand {
        public uint vertexCount;
        public uint instanceCount;
        public uint firstVertex;
        public uint firstInstance;
    }

    public struct VkDrawIndexedIndirectCommand {
        public uint indexCount;
        public uint instanceCount;
        public uint firstIndex;
        public int vertexOffset;
        public uint firstInstance;
    }

    public struct VkDispatchIndirectCommand {
        public uint x;
        public uint y;
        public uint z;
    }

    public struct VkSubmitInfo {
        public VkStructureType sType;
        public IntPtr pNext;
        public uint waitSemaphoreCount;
        public VkSemaphore[] pWaitSemaphores;
        public VkPipelineStageFlags[] pWaitDstStageMask;
        public uint commandBufferCount;
        public VkCommandBuffer[] pCommandBuffers;
        public uint signalSemaphoreCount;
        public VkSemaphore[] pSignalSemaphores;
    }

    public struct VkDisplayPropertiesKHR {
        public VkDisplayKHR display;
        public string displayName;
        public VkExtent2D physicalDimensions;
        public VkExtent2D physicalResolution;
        public VkSurfaceTransformFlagsKHR supportedTransforms;
        public bool planeReorderPossible;
        public bool persistentContent;
    }

    public struct VkDisplayPlanePropertiesKHR {
        public VkDisplayKHR currentDisplay;
        public uint currentStackIndex;
    }

    public struct VkDisplayModeParametersKHR {
        public VkExtent2D visibleRegion;
        public uint refreshRate;
    }

    public struct VkDisplayModePropertiesKHR {
        public VkDisplayModeKHR displayMode;
        public VkDisplayModeParametersKHR parameters;
    }

    public struct VkDisplayModeCreateInfoKHR {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkDisplayModeCreateFlagsKHR flags;
        public VkDisplayModeParametersKHR parameters;
    }

    public struct VkDisplayPlaneCapabilitiesKHR {
        public VkDisplayPlaneAlphaFlagsKHR supportedAlpha;
        public VkOffset2D minSrcPosition;
        public VkOffset2D maxSrcPosition;
        public VkExtent2D minSrcExtent;
        public VkExtent2D maxSrcExtent;
        public VkOffset2D minDstPosition;
        public VkOffset2D maxDstPosition;
        public VkExtent2D minDstExtent;
        public VkExtent2D maxDstExtent;
    }

    public struct VkDisplaySurfaceCreateInfoKHR {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkDisplaySurfaceCreateFlagsKHR flags;
        public VkDisplayModeKHR displayMode;
        public uint planeIndex;
        public uint planeStackIndex;
        public VkSurfaceTransformFlagsKHR transform;
        public float globalAlpha;
        public VkDisplayPlaneAlphaFlagsKHR alphaMode;
        public VkExtent2D imageExtent;
    }

    public struct VkDisplayPresentInfoKHR {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkRect2D srcRect;
        public VkRect2D dstRect;
        public bool persistent;
    }

    public struct VkSurfaceCapabilitiesKHR {
        public uint minImageCount;
        public uint maxImageCount;
        public VkExtent2D currentExtent;
        public VkExtent2D minImageExtent;
        public VkExtent2D maxImageExtent;
        public uint maxImageArrayLayers;
        public VkSurfaceTransformFlagsKHR supportedTransforms;
        public VkSurfaceTransformFlagsKHR currentTransform;
        public VkCompositeAlphaFlagsKHR supportedCompositeAlpha;
        public VkImageUsageFlags supportedUsageFlags;
    }

    public struct VkSurfaceFormatKHR {
        public VkFormat format;
        public VkColorSpaceKHR colorSpace;
    }

    public struct VkSwapchainCreateInfoKHR {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkSwapchainCreateFlagsKHR flags;
        public VkSurfaceKHR surface;
        public uint minImageCount;
        public VkFormat imageFormat;
        public VkColorSpaceKHR imageColorSpace;
        public VkExtent2D imageExtent;
        public uint imageArrayLayers;
        public VkImageUsageFlags imageUsage;
        public VkSharingMode imageSharingMode;
        public uint queueFamilyIndexCount;
        public uint[] pQueueFamilyIndices;
        public VkSurfaceTransformFlagsKHR preTransform;
        public VkCompositeAlphaFlagsKHR compositeAlpha;
        public VkPresentModeKHR presentMode;
        public bool clipped;
        public VkSwapchainKHR oldSwapchain;
    }

    public struct VkPresentInfoKHR {
        public VkStructureType sType;
        public IntPtr pNext;
        public uint waitSemaphoreCount;
        public VkSemaphore[] pWaitSemaphores;
        public uint swapchainCount;
        public VkSwapchainKHR[] pSwapchains;
        public uint[] pImageIndices;
        public VkResult[] pResults;
    }

    public struct VkDebugReportCallbackCreateInfoEXT {
        public VkStructureType sType;
        public IntPtr pNext;
        public VkDebugReportFlagsEXT flags;
        public IntPtr pfnCallback;
        public IntPtr pUserData;
    }

}
