//autogenerated on 8/4/2016 8:00:15 PM
using System;
using System.Runtime.InteropServices;

namespace CSGL.Vulkan.Unmanaged {
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkInstance : IEquatable<VkInstance> {
        public IntPtr native;

        public static VkInstance Null { get; } = new VkInstance();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkInstance other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkInstance) {
                return Equals((VkInstance)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkInstance a, VkInstance b) {
            return a.Equals(b);
        }

        public static bool operator != (VkInstance a, VkInstance b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkPhysicalDevice : IEquatable<VkPhysicalDevice> {
        public IntPtr native;

        public static VkPhysicalDevice Null { get; } = new VkPhysicalDevice();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkPhysicalDevice other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkPhysicalDevice) {
                return Equals((VkPhysicalDevice)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkPhysicalDevice a, VkPhysicalDevice b) {
            return a.Equals(b);
        }

        public static bool operator != (VkPhysicalDevice a, VkPhysicalDevice b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDevice : IEquatable<VkDevice> {
        public IntPtr native;

        public static VkDevice Null { get; } = new VkDevice();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkDevice other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkDevice) {
                return Equals((VkDevice)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkDevice a, VkDevice b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDevice a, VkDevice b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkQueue : IEquatable<VkQueue> {
        public IntPtr native;

        public static VkQueue Null { get; } = new VkQueue();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkQueue other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkQueue) {
                return Equals((VkQueue)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkQueue a, VkQueue b) {
            return a.Equals(b);
        }

        public static bool operator != (VkQueue a, VkQueue b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkCommandBuffer : IEquatable<VkCommandBuffer> {
        public IntPtr native;

        public static VkCommandBuffer Null { get; } = new VkCommandBuffer();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkCommandBuffer other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkCommandBuffer) {
                return Equals((VkCommandBuffer)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkCommandBuffer a, VkCommandBuffer b) {
            return a.Equals(b);
        }

        public static bool operator != (VkCommandBuffer a, VkCommandBuffer b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDeviceMemory : IEquatable<VkDeviceMemory> {
        public IntPtr native;

        public static VkDeviceMemory Null { get; } = new VkDeviceMemory();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkDeviceMemory other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkDeviceMemory) {
                return Equals((VkDeviceMemory)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkDeviceMemory a, VkDeviceMemory b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDeviceMemory a, VkDeviceMemory b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkCommandPool : IEquatable<VkCommandPool> {
        public IntPtr native;

        public static VkCommandPool Null { get; } = new VkCommandPool();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkCommandPool other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkCommandPool) {
                return Equals((VkCommandPool)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkCommandPool a, VkCommandPool b) {
            return a.Equals(b);
        }

        public static bool operator != (VkCommandPool a, VkCommandPool b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkBuffer : IEquatable<VkBuffer> {
        public IntPtr native;

        public static VkBuffer Null { get; } = new VkBuffer();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkBuffer other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkBuffer) {
                return Equals((VkBuffer)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkBuffer a, VkBuffer b) {
            return a.Equals(b);
        }

        public static bool operator != (VkBuffer a, VkBuffer b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkBufferView : IEquatable<VkBufferView> {
        public IntPtr native;

        public static VkBufferView Null { get; } = new VkBufferView();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkBufferView other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkBufferView) {
                return Equals((VkBufferView)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkBufferView a, VkBufferView b) {
            return a.Equals(b);
        }

        public static bool operator != (VkBufferView a, VkBufferView b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkImage : IEquatable<VkImage> {
        public IntPtr native;

        public static VkImage Null { get; } = new VkImage();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkImage other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkImage) {
                return Equals((VkImage)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkImage a, VkImage b) {
            return a.Equals(b);
        }

        public static bool operator != (VkImage a, VkImage b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkImageView : IEquatable<VkImageView> {
        public IntPtr native;

        public static VkImageView Null { get; } = new VkImageView();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkImageView other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkImageView) {
                return Equals((VkImageView)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkImageView a, VkImageView b) {
            return a.Equals(b);
        }

        public static bool operator != (VkImageView a, VkImageView b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkShaderModule : IEquatable<VkShaderModule> {
        public IntPtr native;

        public static VkShaderModule Null { get; } = new VkShaderModule();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkShaderModule other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkShaderModule) {
                return Equals((VkShaderModule)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkShaderModule a, VkShaderModule b) {
            return a.Equals(b);
        }

        public static bool operator != (VkShaderModule a, VkShaderModule b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkPipeline : IEquatable<VkPipeline> {
        public IntPtr native;

        public static VkPipeline Null { get; } = new VkPipeline();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkPipeline other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkPipeline) {
                return Equals((VkPipeline)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkPipeline a, VkPipeline b) {
            return a.Equals(b);
        }

        public static bool operator != (VkPipeline a, VkPipeline b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkPipelineLayout : IEquatable<VkPipelineLayout> {
        public IntPtr native;

        public static VkPipelineLayout Null { get; } = new VkPipelineLayout();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkPipelineLayout other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkPipelineLayout) {
                return Equals((VkPipelineLayout)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkPipelineLayout a, VkPipelineLayout b) {
            return a.Equals(b);
        }

        public static bool operator != (VkPipelineLayout a, VkPipelineLayout b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkSampler : IEquatable<VkSampler> {
        public IntPtr native;

        public static VkSampler Null { get; } = new VkSampler();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkSampler other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkSampler) {
                return Equals((VkSampler)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkSampler a, VkSampler b) {
            return a.Equals(b);
        }

        public static bool operator != (VkSampler a, VkSampler b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDescriptorSet : IEquatable<VkDescriptorSet> {
        public IntPtr native;

        public static VkDescriptorSet Null { get; } = new VkDescriptorSet();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkDescriptorSet other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkDescriptorSet) {
                return Equals((VkDescriptorSet)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkDescriptorSet a, VkDescriptorSet b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDescriptorSet a, VkDescriptorSet b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDescriptorSetLayout : IEquatable<VkDescriptorSetLayout> {
        public IntPtr native;

        public static VkDescriptorSetLayout Null { get; } = new VkDescriptorSetLayout();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkDescriptorSetLayout other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkDescriptorSetLayout) {
                return Equals((VkDescriptorSetLayout)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkDescriptorSetLayout a, VkDescriptorSetLayout b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDescriptorSetLayout a, VkDescriptorSetLayout b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDescriptorPool : IEquatable<VkDescriptorPool> {
        public IntPtr native;

        public static VkDescriptorPool Null { get; } = new VkDescriptorPool();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkDescriptorPool other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkDescriptorPool) {
                return Equals((VkDescriptorPool)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkDescriptorPool a, VkDescriptorPool b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDescriptorPool a, VkDescriptorPool b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkFence : IEquatable<VkFence> {
        public IntPtr native;

        public static VkFence Null { get; } = new VkFence();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkFence other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkFence) {
                return Equals((VkFence)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkFence a, VkFence b) {
            return a.Equals(b);
        }

        public static bool operator != (VkFence a, VkFence b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkSemaphore : IEquatable<VkSemaphore> {
        public IntPtr native;

        public static VkSemaphore Null { get; } = new VkSemaphore();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkSemaphore other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkSemaphore) {
                return Equals((VkSemaphore)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkSemaphore a, VkSemaphore b) {
            return a.Equals(b);
        }

        public static bool operator != (VkSemaphore a, VkSemaphore b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkEvent : IEquatable<VkEvent> {
        public IntPtr native;

        public static VkEvent Null { get; } = new VkEvent();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkEvent other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkEvent) {
                return Equals((VkEvent)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkEvent a, VkEvent b) {
            return a.Equals(b);
        }

        public static bool operator != (VkEvent a, VkEvent b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkQueryPool : IEquatable<VkQueryPool> {
        public IntPtr native;

        public static VkQueryPool Null { get; } = new VkQueryPool();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkQueryPool other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkQueryPool) {
                return Equals((VkQueryPool)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkQueryPool a, VkQueryPool b) {
            return a.Equals(b);
        }

        public static bool operator != (VkQueryPool a, VkQueryPool b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkFramebuffer : IEquatable<VkFramebuffer> {
        public IntPtr native;

        public static VkFramebuffer Null { get; } = new VkFramebuffer();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkFramebuffer other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkFramebuffer) {
                return Equals((VkFramebuffer)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkFramebuffer a, VkFramebuffer b) {
            return a.Equals(b);
        }

        public static bool operator != (VkFramebuffer a, VkFramebuffer b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkRenderPass : IEquatable<VkRenderPass> {
        public IntPtr native;

        public static VkRenderPass Null { get; } = new VkRenderPass();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkRenderPass other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkRenderPass) {
                return Equals((VkRenderPass)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkRenderPass a, VkRenderPass b) {
            return a.Equals(b);
        }

        public static bool operator != (VkRenderPass a, VkRenderPass b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkPipelineCache : IEquatable<VkPipelineCache> {
        public IntPtr native;

        public static VkPipelineCache Null { get; } = new VkPipelineCache();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkPipelineCache other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkPipelineCache) {
                return Equals((VkPipelineCache)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkPipelineCache a, VkPipelineCache b) {
            return a.Equals(b);
        }

        public static bool operator != (VkPipelineCache a, VkPipelineCache b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDisplayKHR : IEquatable<VkDisplayKHR> {
        public IntPtr native;

        public static VkDisplayKHR Null { get; } = new VkDisplayKHR();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkDisplayKHR other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkDisplayKHR) {
                return Equals((VkDisplayKHR)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkDisplayKHR a, VkDisplayKHR b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDisplayKHR a, VkDisplayKHR b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDisplayModeKHR : IEquatable<VkDisplayModeKHR> {
        public IntPtr native;

        public static VkDisplayModeKHR Null { get; } = new VkDisplayModeKHR();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkDisplayModeKHR other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkDisplayModeKHR) {
                return Equals((VkDisplayModeKHR)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkDisplayModeKHR a, VkDisplayModeKHR b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDisplayModeKHR a, VkDisplayModeKHR b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkSurfaceKHR : IEquatable<VkSurfaceKHR> {
        public IntPtr native;

        public static VkSurfaceKHR Null { get; } = new VkSurfaceKHR();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkSurfaceKHR other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkSurfaceKHR) {
                return Equals((VkSurfaceKHR)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkSurfaceKHR a, VkSurfaceKHR b) {
            return a.Equals(b);
        }

        public static bool operator != (VkSurfaceKHR a, VkSurfaceKHR b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkSwapchainKHR : IEquatable<VkSwapchainKHR> {
        public IntPtr native;

        public static VkSwapchainKHR Null { get; } = new VkSwapchainKHR();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkSwapchainKHR other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkSwapchainKHR) {
                return Equals((VkSwapchainKHR)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkSwapchainKHR a, VkSwapchainKHR b) {
            return a.Equals(b);
        }

        public static bool operator != (VkSwapchainKHR a, VkSwapchainKHR b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDebugReportCallbackEXT : IEquatable<VkDebugReportCallbackEXT> {
        public IntPtr native;

        public static VkDebugReportCallbackEXT Null { get; } = new VkDebugReportCallbackEXT();

        public bool IsNull {
            get {
                return this == Null;
            }
        }
        public bool Equals(VkDebugReportCallbackEXT other) {
            return native == other.native;
        }

        public override bool Equals(object other) {
            if (other is VkDebugReportCallbackEXT) {
                return Equals((VkDebugReportCallbackEXT)other);
            }
            return false;
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }

        public static bool operator == (VkDebugReportCallbackEXT a, VkDebugReportCallbackEXT b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDebugReportCallbackEXT a, VkDebugReportCallbackEXT b) {
            return !a.Equals(b);
        }

    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkOffset2D {
        public int x;
        public int y;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkOffset3D {
        public int x;
        public int y;
        public int z;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkExtent2D {
        public uint width;
        public uint height;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkExtent3D {
        public uint width;
        public uint height;
        public uint depth;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkViewport {
        public float x;
        public float y;
        public float width;
        public float height;
        public float minDepth;
        public float maxDepth;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkRect2D {
        public VkOffset2D offset;
        public VkExtent2D extent;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkRect3D {
        public VkOffset3D offset;
        public VkExtent3D extent;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkClearRect {
        public VkRect2D rect;
        public uint baseArrayLayer;
        public uint layerCount;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkComponentMapping {
        public VkComponentSwizzle r;
        public VkComponentSwizzle g;
        public VkComponentSwizzle b;
        public VkComponentSwizzle a;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkPhysicalDeviceProperties {
        public uint apiVersion;
        public uint driverVersion;
        public uint vendorID;
        public uint deviceID;
        public VkPhysicalDeviceType deviceType;
        public char deviceName;
        public byte pipelineCacheUUID;
        public VkPhysicalDeviceLimits limits;
        public VkPhysicalDeviceSparseProperties sparseProperties;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkExtensionProperties {
        public char extensionName;
        public uint specVersion;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkLayerProperties {
        public char layerName;
        public uint specVersion;
        public uint implementationVersion;
        public char description;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkApplicationInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public unsafe byte* pApplicationName;
        public uint applicationVersion;
        public unsafe byte* pEngineName;
        public uint engineVersion;
        public uint apiVersion;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkAllocationCallbacks {
        public unsafe void* pUserData;
        public IntPtr pfnAllocation;
        public IntPtr pfnReallocation;
        public IntPtr pfnFree;
        public IntPtr pfnInternalAllocation;
        public IntPtr pfnInternalFree;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkDeviceQueueCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkDeviceQueueCreateFlags flags;
        public uint queueFamilyIndex;
        public uint queueCount;
        public unsafe float* pQueuePriorities;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkDeviceCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkDeviceCreateFlags flags;
        public uint queueCreateInfoCount;
        public unsafe VkDeviceQueueCreateInfo* pQueueCreateInfos;
        public uint enabledLayerCount;
        public unsafe byte** ppEnabledLayerNames;
        public uint enabledExtensionCount;
        public unsafe byte** ppEnabledExtensionNames;
        public unsafe VkPhysicalDeviceFeatures* pEnabledFeatures;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkInstanceCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkInstanceCreateFlags flags;
        public unsafe VkApplicationInfo* pApplicationInfo;
        public uint enabledLayerCount;
        public unsafe byte** ppEnabledLayerNames;
        public uint enabledExtensionCount;
        public unsafe byte** ppEnabledExtensionNames;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkQueueFamilyProperties {
        public VkQueueFlags queueFlags;
        public uint queueCount;
        public uint timestampValidBits;
        public VkExtent3D minImageTransferGranularity;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkPhysicalDeviceMemoryProperties {
        public uint memoryTypeCount;
        public VkMemoryType memoryTypes;
        public uint memoryHeapCount;
        public VkMemoryHeap memoryHeaps;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkMemoryAllocateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public ulong allocationSize;
        public uint memoryTypeIndex;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkMemoryRequirements {
        public ulong size;
        public ulong alignment;
        public uint memoryTypeBits;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkSparseImageFormatProperties {
        public VkImageAspectFlags aspectMask;
        public VkExtent3D imageGranularity;
        public VkSparseImageFormatFlags flags;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkSparseImageMemoryRequirements {
        public VkSparseImageFormatProperties formatProperties;
        public uint imageMipTailFirstLod;
        public ulong imageMipTailSize;
        public ulong imageMipTailOffset;
        public ulong imageMipTailStride;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkMemoryType {
        public VkMemoryPropertyFlags propertyFlags;
        public uint heapIndex;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkMemoryHeap {
        public ulong size;
        public VkMemoryHeapFlags flags;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkMappedMemoryRange {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkDeviceMemory memory;
        public ulong offset;
        public ulong size;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkFormatProperties {
        public VkFormatFeatureFlags linearTilingFeatures;
        public VkFormatFeatureFlags optimalTilingFeatures;
        public VkFormatFeatureFlags bufferFeatures;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkImageFormatProperties {
        public VkExtent3D maxExtent;
        public uint maxMipLevels;
        public uint maxArrayLayers;
        public VkSampleCountFlags sampleCounts;
        public ulong maxResourceSize;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDescriptorBufferInfo {
        public VkBuffer buffer;
        public ulong offset;
        public ulong range;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDescriptorImageInfo {
        public VkSampler sampler;
        public VkImageView imageView;
        public VkImageLayout imageLayout;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkWriteDescriptorSet {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkDescriptorSet dstSet;
        public uint dstBinding;
        public uint dstArrayElement;
        public uint descriptorCount;
        public VkDescriptorType descriptorType;
        public unsafe VkDescriptorImageInfo* pImageInfo;
        public unsafe VkDescriptorBufferInfo* pBufferInfo;
        public unsafe VkBufferView* pTexelBufferView;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkCopyDescriptorSet {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkDescriptorSet srcSet;
        public uint srcBinding;
        public uint srcArrayElement;
        public VkDescriptorSet dstSet;
        public uint dstBinding;
        public uint dstArrayElement;
        public uint descriptorCount;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkBufferCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkBufferCreateFlags flags;
        public ulong size;
        public VkBufferUsageFlags usage;
        public VkSharingMode sharingMode;
        public uint queueFamilyIndexCount;
        public unsafe uint* pQueueFamilyIndices;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkBufferViewCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkBufferViewCreateFlags flags;
        public VkBuffer buffer;
        public VkFormat format;
        public ulong offset;
        public ulong range;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkImageSubresource {
        public VkImageAspectFlags aspectMask;
        public uint mipLevel;
        public uint arrayLayer;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkImageSubresourceLayers {
        public VkImageAspectFlags aspectMask;
        public uint mipLevel;
        public uint baseArrayLayer;
        public uint layerCount;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkImageSubresourceRange {
        public VkImageAspectFlags aspectMask;
        public uint baseMipLevel;
        public uint levelCount;
        public uint baseArrayLayer;
        public uint layerCount;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkMemoryBarrier {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkAccessFlags srcAccessMask;
        public VkAccessFlags dstAccessMask;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkBufferMemoryBarrier {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkAccessFlags srcAccessMask;
        public VkAccessFlags dstAccessMask;
        public uint srcQueueFamilyIndex;
        public uint dstQueueFamilyIndex;
        public VkBuffer buffer;
        public ulong offset;
        public ulong size;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkImageMemoryBarrier {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkAccessFlags srcAccessMask;
        public VkAccessFlags dstAccessMask;
        public VkImageLayout oldLayout;
        public VkImageLayout newLayout;
        public uint srcQueueFamilyIndex;
        public uint dstQueueFamilyIndex;
        public VkImage image;
        public VkImageSubresourceRange subresourceRange;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkImageCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkImageCreateFlags flags;
        public VkImageType imageType;
        public VkFormat format;
        public VkExtent3D extent;
        public uint mipLevels;
        public uint arrayLayers;
        public VkSampleCountFlags samples;
        public VkImageTiling tiling;
        public VkImageUsageFlags usage;
        public VkSharingMode sharingMode;
        public uint queueFamilyIndexCount;
        public unsafe uint* pQueueFamilyIndices;
        public VkImageLayout initialLayout;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkSubresourceLayout {
        public ulong offset;
        public ulong size;
        public ulong rowPitch;
        public ulong arrayPitch;
        public ulong depthPitch;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkImageViewCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkImageViewCreateFlags flags;
        public VkImage image;
        public VkImageViewType viewType;
        public VkFormat format;
        public VkComponentMapping components;
        public VkImageSubresourceRange subresourceRange;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkBufferCopy {
        public ulong srcOffset;
        public ulong dstOffset;
        public ulong size;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkSparseMemoryBind {
        public ulong resourceOffset;
        public ulong size;
        public VkDeviceMemory memory;
        public ulong memoryOffset;
        public VkSparseMemoryBindFlags flags;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkSparseImageMemoryBind {
        public VkImageSubresource subresource;
        public VkOffset3D offset;
        public VkExtent3D extent;
        public VkDeviceMemory memory;
        public ulong memoryOffset;
        public VkSparseMemoryBindFlags flags;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkSparseBufferMemoryBindInfo {
        public VkBuffer buffer;
        public uint bindCount;
        public unsafe VkSparseMemoryBind* pBinds;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkSparseImageOpaqueMemoryBindInfo {
        public VkImage image;
        public uint bindCount;
        public unsafe VkSparseMemoryBind* pBinds;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkSparseImageMemoryBindInfo {
        public VkImage image;
        public uint bindCount;
        public unsafe VkSparseImageMemoryBind* pBinds;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkBindSparseInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public uint waitSemaphoreCount;
        public unsafe VkSemaphore* pWaitSemaphores;
        public uint bufferBindCount;
        public unsafe VkSparseBufferMemoryBindInfo* pBufferBinds;
        public uint imageOpaqueBindCount;
        public unsafe VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds;
        public uint imageBindCount;
        public unsafe VkSparseImageMemoryBindInfo* pImageBinds;
        public uint signalSemaphoreCount;
        public unsafe VkSemaphore* pSignalSemaphores;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkImageCopy {
        public VkImageSubresourceLayers srcSubresource;
        public VkOffset3D srcOffset;
        public VkImageSubresourceLayers dstSubresource;
        public VkOffset3D dstOffset;
        public VkExtent3D extent;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkImageBlit {
        public VkImageSubresourceLayers srcSubresource;
        public VkOffset3D srcOffsets;
        public VkImageSubresourceLayers dstSubresource;
        public VkOffset3D dstOffsets;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkBufferImageCopy {
        public ulong bufferOffset;
        public uint bufferRowLength;
        public uint bufferImageHeight;
        public VkImageSubresourceLayers imageSubresource;
        public VkOffset3D imageOffset;
        public VkExtent3D imageExtent;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkImageResolve {
        public VkImageSubresourceLayers srcSubresource;
        public VkOffset3D srcOffset;
        public VkImageSubresourceLayers dstSubresource;
        public VkOffset3D dstOffset;
        public VkExtent3D extent;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkShaderModuleCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkShaderModuleCreateFlags flags;
        public long codeSize;
        public unsafe uint* pCode;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkDescriptorSetLayoutBinding {
        public uint binding;
        public VkDescriptorType descriptorType;
        public uint descriptorCount;
        public VkShaderStageFlags stageFlags;
        public unsafe VkSampler* pImmutableSamplers;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkDescriptorSetLayoutCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkDescriptorSetLayoutCreateFlags flags;
        public uint bindingCount;
        public unsafe VkDescriptorSetLayoutBinding* pBindings;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDescriptorPoolSize {
        public VkDescriptorType type;
        public uint descriptorCount;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkDescriptorPoolCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkDescriptorPoolCreateFlags flags;
        public uint maxSets;
        public uint poolSizeCount;
        public unsafe VkDescriptorPoolSize* pPoolSizes;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkDescriptorSetAllocateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkDescriptorPool descriptorPool;
        public uint descriptorSetCount;
        public unsafe VkDescriptorSetLayout* pSetLayouts;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkSpecializationMapEntry {
        public uint constantID;
        public uint offset;
        public long size;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkSpecializationInfo {
        public uint mapEntryCount;
        public unsafe VkSpecializationMapEntry* pMapEntries;
        public long dataSize;
        public unsafe void* pData;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkPipelineShaderStageCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkPipelineShaderStageCreateFlags flags;
        public VkShaderStageFlags stage;
        public VkShaderModule module;
        public unsafe byte* pName;
        public unsafe VkSpecializationInfo* pSpecializationInfo;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkComputePipelineCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkPipelineCreateFlags flags;
        public VkPipelineShaderStageCreateInfo stage;
        public VkPipelineLayout layout;
        public VkPipeline basePipelineHandle;
        public int basePipelineIndex;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkVertexInputBindingDescription {
        public uint binding;
        public uint stride;
        public VkVertexInputRate inputRate;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkVertexInputAttributeDescription {
        public uint location;
        public uint binding;
        public VkFormat format;
        public uint offset;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkPipelineVertexInputStateCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkPipelineVertexInputStateCreateFlags flags;
        public uint vertexBindingDescriptionCount;
        public unsafe VkVertexInputBindingDescription* pVertexBindingDescriptions;
        public uint vertexAttributeDescriptionCount;
        public unsafe VkVertexInputAttributeDescription* pVertexAttributeDescriptions;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkPipelineInputAssemblyStateCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkPipelineInputAssemblyStateCreateFlags flags;
        public VkPrimitiveTopology topology;
        public uint primitiveRestartEnable;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkPipelineTessellationStateCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkPipelineTessellationStateCreateFlags flags;
        public uint patchControlPoints;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkPipelineViewportStateCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkPipelineViewportStateCreateFlags flags;
        public uint viewportCount;
        public unsafe VkViewport* pViewports;
        public uint scissorCount;
        public unsafe VkRect2D* pScissors;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkPipelineRasterizationStateCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkPipelineRasterizationStateCreateFlags flags;
        public uint depthClampEnable;
        public uint rasterizerDiscardEnable;
        public VkPolygonMode polygonMode;
        public VkCullModeFlags cullMode;
        public VkFrontFace frontFace;
        public uint depthBiasEnable;
        public float depthBiasConstantFactor;
        public float depthBiasClamp;
        public float depthBiasSlopeFactor;
        public float lineWidth;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkPipelineMultisampleStateCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkPipelineMultisampleStateCreateFlags flags;
        public VkSampleCountFlags rasterizationSamples;
        public uint sampleShadingEnable;
        public float minSampleShading;
        public unsafe uint* pSampleMask;
        public uint alphaToCoverageEnable;
        public uint alphaToOneEnable;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkPipelineColorBlendAttachmentState {
        public uint blendEnable;
        public VkBlendFactor srcColorBlendFactor;
        public VkBlendFactor dstColorBlendFactor;
        public VkBlendOp colorBlendOp;
        public VkBlendFactor srcAlphaBlendFactor;
        public VkBlendFactor dstAlphaBlendFactor;
        public VkBlendOp alphaBlendOp;
        public VkColorComponentFlags colorWriteMask;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkPipelineColorBlendStateCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkPipelineColorBlendStateCreateFlags flags;
        public uint logicOpEnable;
        public VkLogicOp logicOp;
        public uint attachmentCount;
        public unsafe VkPipelineColorBlendAttachmentState* pAttachments;
        public float blendConstants;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkPipelineDynamicStateCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkPipelineDynamicStateCreateFlags flags;
        public uint dynamicStateCount;
        public unsafe VkDynamicState* pDynamicStates;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkStencilOpState {
        public VkStencilOp failOp;
        public VkStencilOp passOp;
        public VkStencilOp depthFailOp;
        public VkCompareOp compareOp;
        public uint compareMask;
        public uint writeMask;
        public uint reference;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkPipelineDepthStencilStateCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkPipelineDepthStencilStateCreateFlags flags;
        public uint depthTestEnable;
        public uint depthWriteEnable;
        public VkCompareOp depthCompareOp;
        public uint depthBoundsTestEnable;
        public uint stencilTestEnable;
        public VkStencilOpState front;
        public VkStencilOpState back;
        public float minDepthBounds;
        public float maxDepthBounds;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkGraphicsPipelineCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkPipelineCreateFlags flags;
        public uint stageCount;
        public unsafe VkPipelineShaderStageCreateInfo* pStages;
        public unsafe VkPipelineVertexInputStateCreateInfo* pVertexInputState;
        public unsafe VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState;
        public unsafe VkPipelineTessellationStateCreateInfo* pTessellationState;
        public unsafe VkPipelineViewportStateCreateInfo* pViewportState;
        public unsafe VkPipelineRasterizationStateCreateInfo* pRasterizationState;
        public unsafe VkPipelineMultisampleStateCreateInfo* pMultisampleState;
        public unsafe VkPipelineDepthStencilStateCreateInfo* pDepthStencilState;
        public unsafe VkPipelineColorBlendStateCreateInfo* pColorBlendState;
        public unsafe VkPipelineDynamicStateCreateInfo* pDynamicState;
        public VkPipelineLayout layout;
        public VkRenderPass renderPass;
        public uint subpass;
        public VkPipeline basePipelineHandle;
        public int basePipelineIndex;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkPipelineCacheCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkPipelineCacheCreateFlags flags;
        public long initialDataSize;
        public unsafe void* pInitialData;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkPushConstantRange {
        public VkShaderStageFlags stageFlags;
        public uint offset;
        public uint size;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkPipelineLayoutCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkPipelineLayoutCreateFlags flags;
        public uint setLayoutCount;
        public unsafe VkDescriptorSetLayout* pSetLayouts;
        public uint pushConstantRangeCount;
        public unsafe VkPushConstantRange* pPushConstantRanges;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkSamplerCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkSamplerCreateFlags flags;
        public VkFilter magFilter;
        public VkFilter minFilter;
        public VkSamplerMipmapMode mipmapMode;
        public VkSamplerAddressMode addressModeU;
        public VkSamplerAddressMode addressModeV;
        public VkSamplerAddressMode addressModeW;
        public float mipLodBias;
        public uint anisotropyEnable;
        public float maxAnisotropy;
        public uint compareEnable;
        public VkCompareOp compareOp;
        public float minLod;
        public float maxLod;
        public VkBorderColor borderColor;
        public uint unnormalizedCoordinates;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkCommandPoolCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkCommandPoolCreateFlags flags;
        public uint queueFamilyIndex;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkCommandBufferAllocateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkCommandPool commandPool;
        public VkCommandBufferLevel level;
        public uint commandBufferCount;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkCommandBufferInheritanceInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkRenderPass renderPass;
        public uint subpass;
        public VkFramebuffer framebuffer;
        public uint occlusionQueryEnable;
        public VkQueryControlFlags queryFlags;
        public VkQueryPipelineStatisticFlags pipelineStatistics;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkCommandBufferBeginInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkCommandBufferUsageFlags flags;
        public unsafe VkCommandBufferInheritanceInfo* pInheritanceInfo;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkRenderPassBeginInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkRenderPass renderPass;
        public VkFramebuffer framebuffer;
        public VkRect2D renderArea;
        public uint clearValueCount;
        public unsafe VkClearValue* pClearValues;
    }

    [StructLayout(LayoutKind.Explicit, Pack = 1)] //union
    public struct VkClearColorValue {
        [FieldOffset(0)]
        public float float32;
        [FieldOffset(0)]
        public int int32;
        [FieldOffset(0)]
        public uint uint32;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkClearDepthStencilValue {
        public float depth;
        public uint stencil;
    }

    [StructLayout(LayoutKind.Explicit, Pack = 1)] //union
    public struct VkClearValue {
        [FieldOffset(0)]
        public VkClearColorValue color;
        [FieldOffset(0)]
        public VkClearDepthStencilValue depthStencil;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkClearAttachment {
        public VkImageAspectFlags aspectMask;
        public uint colorAttachment;
        public VkClearValue clearValue;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkAttachmentDescription {
        public VkAttachmentDescriptionFlags flags;
        public VkFormat format;
        public VkSampleCountFlags samples;
        public VkAttachmentLoadOp loadOp;
        public VkAttachmentStoreOp storeOp;
        public VkAttachmentLoadOp stencilLoadOp;
        public VkAttachmentStoreOp stencilStoreOp;
        public VkImageLayout initialLayout;
        public VkImageLayout finalLayout;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkAttachmentReference {
        public uint attachment;
        public VkImageLayout layout;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkSubpassDescription {
        public VkSubpassDescriptionFlags flags;
        public VkPipelineBindPoint pipelineBindPoint;
        public uint inputAttachmentCount;
        public unsafe VkAttachmentReference* pInputAttachments;
        public uint colorAttachmentCount;
        public unsafe VkAttachmentReference* pColorAttachments;
        public unsafe VkAttachmentReference* pResolveAttachments;
        public unsafe VkAttachmentReference* pDepthStencilAttachment;
        public uint preserveAttachmentCount;
        public unsafe uint* pPreserveAttachments;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkSubpassDependency {
        public uint srcSubpass;
        public uint dstSubpass;
        public VkPipelineStageFlags srcStageMask;
        public VkPipelineStageFlags dstStageMask;
        public VkAccessFlags srcAccessMask;
        public VkAccessFlags dstAccessMask;
        public VkDependencyFlags dependencyFlags;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkRenderPassCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkRenderPassCreateFlags flags;
        public uint attachmentCount;
        public unsafe VkAttachmentDescription* pAttachments;
        public uint subpassCount;
        public unsafe VkSubpassDescription* pSubpasses;
        public uint dependencyCount;
        public unsafe VkSubpassDependency* pDependencies;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkEventCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkEventCreateFlags flags;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkFenceCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkFenceCreateFlags flags;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkPhysicalDeviceFeatures {
        public uint robustBufferAccess;
        public uint fullDrawIndexUint32;
        public uint imageCubeArray;
        public uint independentBlend;
        public uint geometryShader;
        public uint tessellationShader;
        public uint sampleRateShading;
        public uint dualSrcBlend;
        public uint logicOp;
        public uint multiDrawIndirect;
        public uint drawIndirectFirstInstance;
        public uint depthClamp;
        public uint depthBiasClamp;
        public uint fillModeNonSolid;
        public uint depthBounds;
        public uint wideLines;
        public uint largePoints;
        public uint alphaToOne;
        public uint multiViewport;
        public uint samplerAnisotropy;
        public uint textureCompressionETC2;
        public uint textureCompressionASTC_LDR;
        public uint textureCompressionBC;
        public uint occlusionQueryPrecise;
        public uint pipelineStatisticsQuery;
        public uint vertexPipelineStoresAndAtomics;
        public uint fragmentStoresAndAtomics;
        public uint shaderTessellationAndGeometryPointSize;
        public uint shaderImageGatherExtended;
        public uint shaderStorageImageExtendedFormats;
        public uint shaderStorageImageMultisample;
        public uint shaderStorageImageReadWithoutFormat;
        public uint shaderStorageImageWriteWithoutFormat;
        public uint shaderUniformBufferArrayDynamicIndexing;
        public uint shaderSampledImageArrayDynamicIndexing;
        public uint shaderStorageBufferArrayDynamicIndexing;
        public uint shaderStorageImageArrayDynamicIndexing;
        public uint shaderClipDistance;
        public uint shaderCullDistance;
        public uint shaderFloat64;
        public uint shaderInt64;
        public uint shaderInt16;
        public uint shaderResourceResidency;
        public uint shaderResourceMinLod;
        public uint sparseBinding;
        public uint sparseResidencyBuffer;
        public uint sparseResidencyImage2D;
        public uint sparseResidencyImage3D;
        public uint sparseResidency2Samples;
        public uint sparseResidency4Samples;
        public uint sparseResidency8Samples;
        public uint sparseResidency16Samples;
        public uint sparseResidencyAliased;
        public uint variableMultisampleRate;
        public uint inheritedQueries;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkPhysicalDeviceSparseProperties {
        public uint residencyStandard2DBlockShape;
        public uint residencyStandard2DMultisampleBlockShape;
        public uint residencyStandard3DBlockShape;
        public uint residencyAlignedMipSize;
        public uint residencyNonResidentStrict;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkPhysicalDeviceLimits {
        public uint maxImageDimension1D;
        public uint maxImageDimension2D;
        public uint maxImageDimension3D;
        public uint maxImageDimensionCube;
        public uint maxImageArrayLayers;
        public uint maxTexelBufferElements;
        public uint maxUniformBufferRange;
        public uint maxStorageBufferRange;
        public uint maxPushConstantsSize;
        public uint maxMemoryAllocationCount;
        public uint maxSamplerAllocationCount;
        public ulong bufferImageGranularity;
        public ulong sparseAddressSpaceSize;
        public uint maxBoundDescriptorSets;
        public uint maxPerStageDescriptorSamplers;
        public uint maxPerStageDescriptorUniformBuffers;
        public uint maxPerStageDescriptorStorageBuffers;
        public uint maxPerStageDescriptorSampledImages;
        public uint maxPerStageDescriptorStorageImages;
        public uint maxPerStageDescriptorInputAttachments;
        public uint maxPerStageResources;
        public uint maxDescriptorSetSamplers;
        public uint maxDescriptorSetUniformBuffers;
        public uint maxDescriptorSetUniformBuffersDynamic;
        public uint maxDescriptorSetStorageBuffers;
        public uint maxDescriptorSetStorageBuffersDynamic;
        public uint maxDescriptorSetSampledImages;
        public uint maxDescriptorSetStorageImages;
        public uint maxDescriptorSetInputAttachments;
        public uint maxVertexInputAttributes;
        public uint maxVertexInputBindings;
        public uint maxVertexInputAttributeOffset;
        public uint maxVertexInputBindingStride;
        public uint maxVertexOutputComponents;
        public uint maxTessellationGenerationLevel;
        public uint maxTessellationPatchSize;
        public uint maxTessellationControlPerVertexInputComponents;
        public uint maxTessellationControlPerVertexOutputComponents;
        public uint maxTessellationControlPerPatchOutputComponents;
        public uint maxTessellationControlTotalOutputComponents;
        public uint maxTessellationEvaluationInputComponents;
        public uint maxTessellationEvaluationOutputComponents;
        public uint maxGeometryShaderInvocations;
        public uint maxGeometryInputComponents;
        public uint maxGeometryOutputComponents;
        public uint maxGeometryOutputVertices;
        public uint maxGeometryTotalOutputComponents;
        public uint maxFragmentInputComponents;
        public uint maxFragmentOutputAttachments;
        public uint maxFragmentDualSrcAttachments;
        public uint maxFragmentCombinedOutputResources;
        public uint maxComputeSharedMemorySize;
        public uint maxComputeWorkGroupCount;
        public uint maxComputeWorkGroupInvocations;
        public uint maxComputeWorkGroupSize;
        public uint subPixelPrecisionBits;
        public uint subTexelPrecisionBits;
        public uint mipmapPrecisionBits;
        public uint maxDrawIndexedIndexValue;
        public uint maxDrawIndirectCount;
        public float maxSamplerLodBias;
        public float maxSamplerAnisotropy;
        public uint maxViewports;
        public uint maxViewportDimensions;
        public float viewportBoundsRange;
        public uint viewportSubPixelBits;
        public long minMemoryMapAlignment;
        public ulong minTexelBufferOffsetAlignment;
        public ulong minUniformBufferOffsetAlignment;
        public ulong minStorageBufferOffsetAlignment;
        public int minTexelOffset;
        public uint maxTexelOffset;
        public int minTexelGatherOffset;
        public uint maxTexelGatherOffset;
        public float minInterpolationOffset;
        public float maxInterpolationOffset;
        public uint subPixelInterpolationOffsetBits;
        public uint maxFramebufferWidth;
        public uint maxFramebufferHeight;
        public uint maxFramebufferLayers;
        public VkSampleCountFlags framebufferColorSampleCounts;
        public VkSampleCountFlags framebufferDepthSampleCounts;
        public VkSampleCountFlags framebufferStencilSampleCounts;
        public VkSampleCountFlags framebufferNoAttachmentsSampleCounts;
        public uint maxColorAttachments;
        public VkSampleCountFlags sampledImageColorSampleCounts;
        public VkSampleCountFlags sampledImageIntegerSampleCounts;
        public VkSampleCountFlags sampledImageDepthSampleCounts;
        public VkSampleCountFlags sampledImageStencilSampleCounts;
        public VkSampleCountFlags storageImageSampleCounts;
        public uint maxSampleMaskWords;
        public uint timestampComputeAndGraphics;
        public float timestampPeriod;
        public uint maxClipDistances;
        public uint maxCullDistances;
        public uint maxCombinedClipAndCullDistances;
        public uint discreteQueuePriorities;
        public float pointSizeRange;
        public float lineWidthRange;
        public float pointSizeGranularity;
        public float lineWidthGranularity;
        public uint strictLines;
        public uint standardSampleLocations;
        public ulong optimalBufferCopyOffsetAlignment;
        public ulong optimalBufferCopyRowPitchAlignment;
        public ulong nonCoherentAtomSize;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkSemaphoreCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkSemaphoreCreateFlags flags;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkQueryPoolCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkQueryPoolCreateFlags flags;
        public VkQueryType queryType;
        public uint queryCount;
        public VkQueryPipelineStatisticFlags pipelineStatistics;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkFramebufferCreateInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkFramebufferCreateFlags flags;
        public VkRenderPass renderPass;
        public uint attachmentCount;
        public unsafe VkImageView* pAttachments;
        public uint width;
        public uint height;
        public uint layers;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDrawIndirectCommand {
        public uint vertexCount;
        public uint instanceCount;
        public uint firstVertex;
        public uint firstInstance;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDrawIndexedIndirectCommand {
        public uint indexCount;
        public uint instanceCount;
        public uint firstIndex;
        public int vertexOffset;
        public uint firstInstance;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDispatchIndirectCommand {
        public uint x;
        public uint y;
        public uint z;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkSubmitInfo {
        public VkStructureType sType;
        public unsafe void* pNext;
        public uint waitSemaphoreCount;
        public unsafe VkSemaphore* pWaitSemaphores;
        public unsafe VkPipelineStageFlags* pWaitDstStageMask;
        public uint commandBufferCount;
        public unsafe VkCommandBuffer* pCommandBuffers;
        public uint signalSemaphoreCount;
        public unsafe VkSemaphore* pSignalSemaphores;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkDisplayPropertiesKHR {
        public VkDisplayKHR display;
        public unsafe byte* displayName;
        public VkExtent2D physicalDimensions;
        public VkExtent2D physicalResolution;
        public VkSurfaceTransformFlagsKHR supportedTransforms;
        public uint planeReorderPossible;
        public uint persistentContent;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDisplayPlanePropertiesKHR {
        public VkDisplayKHR currentDisplay;
        public uint currentStackIndex;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDisplayModeParametersKHR {
        public VkExtent2D visibleRegion;
        public uint refreshRate;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDisplayModePropertiesKHR {
        public VkDisplayModeKHR displayMode;
        public VkDisplayModeParametersKHR parameters;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkDisplayModeCreateInfoKHR {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkDisplayModeCreateFlagsKHR flags;
        public VkDisplayModeParametersKHR parameters;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkDisplayPlaneCapabilitiesKHR {
        public VkDisplayPlaneAlphaFlagsKHR supportedAlpha;
        public VkOffset2D minSrcPosition;
        public VkOffset2D maxSrcPosition;
        public VkExtent2D minSrcExtent;
        public VkExtent2D maxSrcExtent;
        public VkOffset2D minDstPosition;
        public VkOffset2D maxDstPosition;
        public VkExtent2D minDstExtent;
        public VkExtent2D maxDstExtent;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkDisplaySurfaceCreateInfoKHR {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkDisplaySurfaceCreateFlagsKHR flags;
        public VkDisplayModeKHR displayMode;
        public uint planeIndex;
        public uint planeStackIndex;
        public VkSurfaceTransformFlags transform;
        public float globalAlpha;
        public VkDisplayPlaneAlphaFlags alphaMode;
        public VkExtent2D imageExtent;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkDisplayPresentInfoKHR {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkRect2D srcRect;
        public VkRect2D dstRect;
        public uint persistent;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkSurfaceCapabilitiesKHR {
        public uint minImageCount;
        public uint maxImageCount;
        public VkExtent2D currentExtent;
        public VkExtent2D minImageExtent;
        public VkExtent2D maxImageExtent;
        public uint maxImageArrayLayers;
        public VkSurfaceTransformFlagsKHR supportedTransforms;
        public VkSurfaceTransformFlags currentTransform;
        public VkCompositeAlphaFlagsKHR supportedCompositeAlpha;
        public VkImageUsageFlags supportedUsageFlags;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkWin32SurfaceCreateInfoKHR {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkWin32SurfaceCreateFlagsKHR flags;
        public IntPtr hinstance;
        public IntPtr hwnd;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct VkSurfaceFormatKHR {
        public VkFormat format;
        public VkColorSpaceKHR colorSpace;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkSwapchainCreateInfoKHR {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkSwapchainCreateFlagsKHR flags;
        public VkSurfaceKHR surface;
        public uint minImageCount;
        public VkFormat imageFormat;
        public VkColorSpaceKHR imageColorSpace;
        public VkExtent2D imageExtent;
        public uint imageArrayLayers;
        public VkImageUsageFlags imageUsage;
        public VkSharingMode imageSharingMode;
        public uint queueFamilyIndexCount;
        public unsafe uint* pQueueFamilyIndices;
        public VkSurfaceTransformFlags preTransform;
        public VkCompositeAlphaFlags compositeAlpha;
        public VkPresentModeKHR presentMode;
        public uint clipped;
        public VkSwapchainKHR oldSwapchain;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkPresentInfoKHR {
        public VkStructureType sType;
        public unsafe void* pNext;
        public uint waitSemaphoreCount;
        public unsafe VkSemaphore* pWaitSemaphores;
        public uint swapchainCount;
        public unsafe VkSwapchainKHR* pSwapchains;
        public unsafe uint* pImageIndices;
        public unsafe VkResult* pResults;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct VkDebugReportCallbackCreateInfoEXT {
        public VkStructureType sType;
        public unsafe void* pNext;
        public VkDebugReportFlagsEXT flags;
        public IntPtr pfnCallback;
        public unsafe void* pUserData;
    }

}
